<!DOCTYPE html>
<!--
  This file is part of LoveCall.

  LoveCall is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  LoveCall is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with LoveCall.  If not, see <http://www.gnu.org/licenses/>.
-->
<html lang="en">
<head>
	<meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">
	<title>beats!</title>

</head>
<body>

  <audio id="source" controls="controls">
    <source src="snowhare.mp3" type="audio/mp3" />
  </audio>

  <br />

  <canvas id="oscilloscope" width="512" height="256">
  </canvas>

  <canvas id="fft" width="512" height="256">
  </canvas>

  <br />

  <canvas id="result-oscilloscope" width="512" height="256">
  </canvas>

  <canvas id="result-fft" width="512" height="256">
  </canvas>

  <script>
'use strict';

var oscElem = document.getElementById('oscilloscope');
var fftElem = document.getElementById('fft');

var rOscElem = document.getElementById('result-oscilloscope');
var rFftElem = document.getElementById('result-fft');

var ctx = new AudioContext();
var sourceNode = ctx.createMediaElementSource(document.getElementById('source'));
var lpNode = ctx.createBiquadFilter();
var cNode = ctx.createDynamicsCompressor();

var resultNode = cNode;
var outNode = sourceNode;

var coarseAnalyserNode = ctx.createAnalyser();
var fineAnalyserNode = ctx.createAnalyser();
var rCoarseAnalyserNode = ctx.createAnalyser();
var rFineAnalyserNode = ctx.createAnalyser();


lpNode.frequency.value = 200;
lpNode.type = 'lowpass';

cNode.threshold.value = -20;
cNode.knee.value = 20;
cNode.ratio.value = 12;
cNode.reduction.value = -12;
cNode.attack.value = 0;
cNode.release.value = 0.1;

coarseAnalyserNode.fftSize = rCoarseAnalyserNode.fftSize = 512;
fineAnalyserNode.fftSize = rFineAnalyserNode.fftSize = 1024;
var coarseBufferLength = coarseAnalyserNode.frequencyBinCount;
var fineBufferLength = fineAnalyserNode.frequencyBinCount;
var coarseArray = new Uint8Array(coarseBufferLength);
var fineArray = new Uint8Array(fineBufferLength);
var rCoarseArray = new Uint8Array(coarseBufferLength);
var rFineArray = new Uint8Array(fineBufferLength);


var oscFrameCallbackFactory = function(oscElem, node, arr) {
  var oscW = oscElem.width;
  var oscH = oscElem.height;
  var oscCtx = oscElem.getContext('2d');
  var buflen = arr.length;

  return function(ts) {
    oscCtx.fillStyle = '#eee';
    oscCtx.fillRect(0, 0, oscW, oscH);

    node.getByteTimeDomainData(arr);
    // oscCtx.lineWidth = 0.5;
    oscCtx.strokeStyle = '#111';

    oscCtx.beginPath();

    var sliceW = (oscW / buflen);
    var x = 0;

    for (var i = 0; i < buflen; i++) {
      var v = +(arr[i] / 128);
      var y = (v * oscH / 2)|0;

      if (i === 0) {
        oscCtx.moveTo(x, y);
      } else {
        oscCtx.lineTo(x, y);
      }

      x += sliceW;
    }

    oscCtx.stroke();
  };
};


var fftFrameCallbackFactory = function(fftElem, node, arr) {
  var fftW = fftElem.width;
  var fftH = fftElem.height;
  var fftCtx = fftElem.getContext('2d');
  var buflen = arr.length;

  return function(ts) {
    fftCtx.fillStyle = '#eee';
    fftCtx.fillRect(0, 0, fftW, fftH);

    node.getByteFrequencyData(arr);

    var barW = +(fftW / buflen);
    var barHangingH = (fftH * 0.5)|0;
    var barNegativeH = (fftH * 0.5)|0;
    var x = 0;

    fftCtx.fillStyle = '#111';
    for (var i = 0; i < buflen; i++) {
      var v = +((Math.log(arr[i]) - Math.log(256) + 2) / 2);

      var barH;
      var barY;

      if (v < 0) {
        barH = ((1 + v) * barNegativeH)|0;
      } else {
        barH = (v * barHangingH + barNegativeH)|0;
      }

      barY = (fftH - barH)|0;

      fftCtx.fillRect(x, barY, barW - 1, barH);
      x += barW;
    }
  };
};


var oscFC = oscFrameCallbackFactory(oscElem, fineAnalyserNode, fineArray);
var fftFC = fftFrameCallbackFactory(fftElem, coarseAnalyserNode, coarseArray);

var rOscFC = oscFrameCallbackFactory(rOscElem, rFineAnalyserNode, rFineArray);
var rFftFC = fftFrameCallbackFactory(rFftElem, rCoarseAnalyserNode, rCoarseArray);

var frameCallback = function(ts) {
  requestAnimationFrame(frameCallback);

  oscFC(ts);
  fftFC(ts);

  rOscFC(ts);
  rFftFC(ts);
};


sourceNode.connect(coarseAnalyserNode);
sourceNode.connect(fineAnalyserNode);
sourceNode.connect(lpNode);

lpNode.connect(cNode);

resultNode.connect(rCoarseAnalyserNode);
resultNode.connect(rFineAnalyserNode);

outNode.connect(ctx.destination);

requestAnimationFrame(frameCallback);

  </script>
<!-- vim:set ai et ts=2 sw=2 sts=2 fenc=utf-8: -->
</body>
</html>
